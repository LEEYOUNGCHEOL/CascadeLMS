class CreateStyleChecks < ActiveRecord::Migration
  def self.up
    create_table :style_checks do |t|
      t.column :name, :string
      t.column :description, :text
      t.column :example, :text
      t.column :bias, :boolean, :null => false, :default => true
      # t.column :name, :string
    end
    
    StyleCheck.create :name => 'IdempotentOperations', :description => 'Avoid idempotent operations - they are silly.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;int&nbsp;x&nbsp;=&nbsp;2;<br/>&nbsp;&nbsp;x&nbsp;=&nbsp;x;<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'EmptyTryBlock', :description => 'Avoid empty try blocks - what\'s the point?',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;try&nbsp;{<br/>&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'BadComparison', :description => 'Avoid equality comparisons with Double.NaN - these are<br/>likely to be logic errors.',  :example => 'public&nbsp;class&nbsp;Bar&nbsp;{<br/>&nbsp;boolean&nbsp;x&nbsp;=&nbsp;(y&nbsp;==&nbsp;Double.NaN);<br/>}'
    StyleCheck.create :name => 'UseStringBufferLength', :description => 'Use StringBuffer.length() to determine StringBuffer length rather than using StringBuffer.toString().equals("")<br/>          or StringBuffer.toString().length() ==',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;StringBuffer&nbsp;sb&nbsp;=&nbsp;new&nbsp;StringBuffer();<br/>&nbsp;&nbsp;//&nbsp;this&nbsp;is&nbsp;bad<br/>&nbsp;&nbsp;if(sb.toString().equals(""))&nbsp;{}<br/>&nbsp;&nbsp;//&nbsp;this&nbsp;is&nbsp;good<br/>&nbsp;&nbsp;if(sb.length()&nbsp;==&nbsp;0)&nbsp;{}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'PreserveStackTrace', :description => 'Throwing a new exception from a catch block without passing the original exception into the <br/>new Exception will cause the true stack trace to be lost, and can cause problems<br/>debugging problems',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;good()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer.parseInt("a");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch(Exception&nbsp;e){<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;Exception(e);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;bad()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer.parseInt("a");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch(Exception&nbsp;e){<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;Exception(e.getMessage());<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'LongVariable', :description => 'Detects when a field, formal or local variable is declared with a long name.',  :example => 'public&nbsp;class&nbsp;Something&nbsp;{<br/>&nbsp;&nbsp;int&nbsp;reallyLongIntName&nbsp;=&nbsp;-3;&nbsp;&nbsp;//&nbsp;VIOLATION&nbsp;-&nbsp;Field<br/>&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(&nbsp;String&nbsp;argumentsList[]&nbsp;)&nbsp;{&nbsp;//&nbsp;VIOLATION&nbsp;-&nbsp;Formal<br/>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;otherReallyLongName&nbsp;=&nbsp;-5;&nbsp;//&nbsp;VIOLATION&nbsp;-&nbsp;Local<br/>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;interestingIntIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;//&nbsp;VIOLATION&nbsp;-&nbsp;For<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interestingIntIndex&nbsp;<&nbsp;10;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interestingIntIndex&nbsp;++&nbsp;)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'SwitchDensity', :description => 'A high ratio of statements to labels in a switch statement implies that the switch<br/> statement is doing too much work.  Consider moving the statements either into new<br/> methods, or creating subclasses based on the switch variable.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;bar(int&nbsp;x)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;switch&nbsp;(x)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;1:&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;lots&nbsp;of&nbsp;statements<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;case&nbsp;2:&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;lots&nbsp;of&nbsp;statements<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'NonCaseLabelInSwitchStatement', :description => 'A non-case label (e.g. a named break/continue label) was present in a switch statement.<br/>This legal, but confusing. It is easy to mix up the case labels and the non-case labels.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;void&nbsp;bar(int&nbsp;a)&nbsp;{<br/>&nbsp;&nbsp;switch&nbsp;(a)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;case&nbsp;1:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>&nbsp;&nbsp;&nbsp;mylabel:&nbsp;//&nbsp;this&nbsp;is&nbsp;legal,&nbsp;but&nbsp;confusing!<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>&nbsp;&nbsp;&nbsp;default:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'UselessStringValueOf', :description => 'Use valueOf() argument directly.',  :example => 'public&nbsp;String&nbsp;convert(int&nbsp;i)&nbsp;{<br/>&nbsp;&nbsp;String&nbsp;s;<br/>&nbsp;&nbsp;s&nbsp;=&nbsp;"a"&nbsp;+&nbsp;String.valueOf(i);&nbsp;//&nbsp;Bad<br/>&nbsp;&nbsp;s&nbsp;=&nbsp;"a"&nbsp;+&nbsp;i;&nbsp;//&nbsp;Better<br/>&nbsp;&nbsp;return&nbsp;s;<br/>}'
    StyleCheck.create :name => 'TooManyFields', :description => 'Classes that have too many fields could be redesigned to have fewer fields, possibly<br/> through some nested object grouping of some of the information.  For example, a class with<br/> city/state/zip fields could instead have one Address field.',  :example => 'public&nbsp;class&nbsp;Person&nbsp;{<br/>&nbsp;&nbsp;&nbsp;String&nbsp;one;<br/>&nbsp;&nbsp;&nbsp;int&nbsp;two;<br/>&nbsp;&nbsp;&nbsp;int&nbsp;three;<br/>&nbsp;&nbsp;&nbsp;[...&nbsp;many&nbsp;more&nbsp;public&nbsp;fields&nbsp;...]<br/>}'
    StyleCheck.create :name => 'InefficientStringBuffering', :description => 'Avoid concatenating non literals in a StringBuffer constructor or append().',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;//&nbsp;Avoid&nbsp;this<br/>&nbsp;&nbsp;StringBuffer&nbsp;sb=new&nbsp;StringBuffer("tmp&nbsp;=&nbsp;"+System.getProperty("java.io.tmpdir"));<br/>&nbsp;&nbsp;//&nbsp;use&nbsp;instead&nbsp;something&nbsp;like&nbsp;this<br/>&nbsp;&nbsp;StringBuffer&nbsp;sb&nbsp;=&nbsp;new&nbsp;StringBuffer("tmp&nbsp;=&nbsp;");<br/>&nbsp;&nbsp;sb.append(System.getProperty("java.io.tmpdir"));<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'AvoidDeeplyNestedIfStmts', :description => 'Deeply nested if..then statements are hard to read.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;bar(int&nbsp;x,&nbsp;int&nbsp;y,&nbsp;int&nbsp;z)&nbsp;{<br/>&nbsp;&nbsp;if&nbsp;(x>y)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;if&nbsp;(y>z)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(z==x)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;whew,&nbsp;too&nbsp;deep<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'FinalizeShouldBeProtected', :description => 'If you override finalize(), make it protected.  If you make<br/> it public, other classes may call it.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;finalize()&nbsp;{<br/>&nbsp;&nbsp;//&nbsp;do&nbsp;something<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'UnusedFormalParameter', :description => 'Avoid passing parameters to methods or constructors and then not using those parameters.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;private&nbsp;void&nbsp;bar(String&nbsp;howdy)&nbsp;{<br/>&nbsp;&nbsp;//&nbsp;howdy&nbsp;is&nbsp;not&nbsp;used<br/>&nbsp;}'
    StyleCheck.create :name => 'AvoidDecimalLiteralsInBigDecimalConstructor', :description => 'One might assume that "new BigDecimal(.1)" is exactly equal<br/>     to .1, but it is actually equal<br/>     to .1000000000000000055511151231257827021181583404541015625.<br/>     This is so because .1 cannot be represented exactly as a double<br/>     (or, for that matter, as a binary fraction of any finite length).<br/>     Thus, the long value that is being passed in to the constructor<br/>     is not exactly equal to .1, appearances notwithstanding.<br/><br/>     The (String) constructor, on the other hand, is perfectly predictable:<br/>     \'new BigDecimal(".1")\' is exactly equal to .1, as one<br/>     would expect.  Therefore, it is generally recommended that the (String)<br/>     constructor be used in preference to this one.',  :example => 'import&nbsp;java.math.BigDecimal;<br/>public&nbsp;class&nbsp;Test&nbsp;{<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;this&nbsp;would&nbsp;trigger&nbsp;the&nbsp;rule<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BigDecimal&nbsp;bd=new&nbsp;BigDecimal(1.123);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;this&nbsp;wouldn\'t&nbsp;trigger&nbsp;the&nbsp;rule<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BigDecimal&nbsp;bd=new&nbsp;BigDecimal("1.123");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;this&nbsp;wouldn\'t&nbsp;trigger&nbsp;the&nbsp;rule<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BigDecimal&nbsp;bd=new&nbsp;BigDecimal(12);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'EmptyCatchBlock', :description => 'Empty Catch Block finds instances where an exception is caught,<br/>but nothing is done.  In most circumstances, this swallows an exception<br/>which should either be acted on or reported.',  :example => 'public&nbsp;void&nbsp;doSomething()&nbsp;{<br/>&nbsp;&nbsp;try&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;FileInputStream&nbsp;fis&nbsp;=&nbsp;new&nbsp;FileInputStream("/tmp/bugger");<br/>&nbsp;&nbsp;}&nbsp;catch&nbsp;(IOException&nbsp;ioe)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;not&nbsp;good<br/>&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'ConfusingTernary', :description => 'In an "if" expression with an "else" clause, avoid negation in<br/>the test.  For example, rephrase:<br/>if (x != y) diff(); else same();<br/>as:<br/>if (x == y) same(); else diff();<br/>Most "if (x != y)" cases without an "else" are often return<br/>cases, so consistent use of this rule makes the code easier<br/>to read.  Also, this resolves trivial ordering problems, such<br/>as "does the error case go first?" or "does the common case<br/>go first?".',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;boolean&nbsp;bar(int&nbsp;x,&nbsp;int&nbsp;y)&nbsp;{<br/>&nbsp;&nbsp;return&nbsp;(x&nbsp;!=&nbsp;y)&nbsp;?&nbsp;diff&nbsp;:&nbsp;same;<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'AbstractClassWithoutAbstractMethod', :description => 'The abstract class does not contain any abstract methods. An abstract class suggests<br/>an incomplete implementation, which is to be completed by subclasses implementing the<br/>abstract methods. If the class is intended to be used as a base class only (not to be instantiated<br/>direcly) a protected constructor can be provided prevent direct instantiation.',  :example => 'public&nbsp;abstract&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;void&nbsp;int&nbsp;method1()&nbsp;{&nbsp;...&nbsp;}<br/>&nbsp;void&nbsp;int&nbsp;method2()&nbsp;{&nbsp;...&nbsp;}<br/>&nbsp;//&nbsp;consider&nbsp;using&nbsp;abstract&nbsp;methods&nbsp;or&nbsp;removing<br/>&nbsp;//&nbsp;the&nbsp;abstract&nbsp;modifier&nbsp;and&nbsp;adding&nbsp;protected&nbsp;constructors<br/>}'
    StyleCheck.create :name => 'UnusedLocalVariable', :description => 'Detects when a local variable is declared and/or assigned, but not used.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;doSomething()&nbsp;{<br/>&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;5;&nbsp;//&nbsp;Unused<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'NoPackage', :description => 'Detects when a class or interface does not have a package definition.',  :example => '//&nbsp;no&nbsp;package&nbsp;declaration<br/>public&nbsp;class&nbsp;ClassInDefaultPackage&nbsp;{<br/>}'
    StyleCheck.create :name => 'MissingBreakInSwitch', :description => 'A switch statement without an enclosed break statement may be a bug.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;bar(int&nbsp;status)&nbsp;{<br/>&nbsp;&nbsp;switch(status)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;case&nbsp;CANCELLED:<br/>&nbsp;&nbsp;&nbsp;&nbsp;doCancelled();<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;break;&nbsp;hm,&nbsp;should&nbsp;this&nbsp;be&nbsp;commented&nbsp;out?<br/>&nbsp;&nbsp;&nbsp;case&nbsp;NEW:<br/>&nbsp;&nbsp;&nbsp;&nbsp;doNew();<br/>&nbsp;&nbsp;&nbsp;case&nbsp;REMOVED:<br/>&nbsp;&nbsp;&nbsp;&nbsp;doRemoved();<br/>&nbsp;&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'AvoidConstantsInterface', :description => 'An interface should be used only to model a behaviour of a<br/>    class: using an interface as a container of constants is a poor usage pattern.',  :example => 'public&nbsp;interface&nbsp;ConstantsInterface&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;final&nbsp;int&nbsp;CONSTANT1=0;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;final&nbsp;String&nbsp;CONSTANT2="1";<br/>&nbsp;&nbsp;&nbsp;&nbsp;}'
    StyleCheck.create :name => 'IfStmtsMustUseBraces', :description => 'Avoid using if statements without using curly braces',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;x&nbsp;=&nbsp;0;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(foo)&nbsp;x++;<br/>&nbsp;&nbsp;&nbsp;}<br/>&nbsp;}'
    StyleCheck.create :name => 'LocalVariableCouldBeFinal', :description => 'A local variable assigned only once can be declared final.',  :example => 'public&nbsp;class&nbsp;Bar&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;foo&nbsp;()&nbsp;{<br/>&nbsp;&nbsp;String&nbsp;a&nbsp;=&nbsp;"a";&nbsp;//if&nbsp;a&nbsp;will&nbsp;not&nbsp;be&nbsp;assigned&nbsp;again&nbsp;it&nbsp;is&nbsp;better&nbsp;to&nbsp;do&nbsp;this:<br/>&nbsp;&nbsp;final&nbsp;String&nbsp;b&nbsp;=&nbsp;"b";<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'UnnecessaryLocalBeforeReturn', :description => 'Avoid unnecessarily creating local variables',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;foo()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;x&nbsp;=&nbsp;doSomething();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;x;&nbsp;&nbsp;//&nbsp;instead,&nbsp;just&nbsp;\'return&nbsp;doSomething();\'<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;}'
    StyleCheck.create :name => 'ShortVariable', :description => 'Detects when a field, local or parameter has a short name.',  :example => 'public&nbsp;class&nbsp;Something&nbsp;{<br/>&nbsp;&nbsp;private&nbsp;int&nbsp;q&nbsp;=&nbsp;15;&nbsp;//&nbsp;VIOLATION&nbsp;-&nbsp;Field<br/>&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(&nbsp;String&nbsp;as[]&nbsp;)&nbsp;{&nbsp;&nbsp;//&nbsp;VIOLATION&nbsp;-&nbsp;Formal<br/>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;20&nbsp;+&nbsp;q;&nbsp;//&nbsp;VIOLATION&nbsp;-&nbsp;Local<br/>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;<&nbsp;10;&nbsp;i++)&nbsp;{&nbsp;//&nbsp;Not&nbsp;a&nbsp;Violation&nbsp;(inside&nbsp;FOR)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;+=&nbsp;q;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'PackageCase', :description => 'Detects when a package definition contains upper case characters.',  :example => 'package&nbsp;com.MyCompany;&nbsp;&nbsp;//&nbsp;<-&nbsp;should&nbsp;be&nbsp;lower&nbsp;case&nbsp;name<br/>public&nbsp;class&nbsp;SomeClass&nbsp;{<br/>}'
    StyleCheck.create :name => 'UnnecessaryReturn', :description => 'Avoid unnecessary return statements',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;int&nbsp;x&nbsp;=&nbsp;42;<br/>&nbsp;&nbsp;return;<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'ExcessiveMethodLength', :description => 'Violations of this rule usually indicate that the method is doing<br/>too much.  Try to reduce the method size by creating helper methods and removing any copy/pasted code.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;doSomething()&nbsp;{<br/>&nbsp;&nbsp;System.out.println("Hello&nbsp;world!");<br/>&nbsp;&nbsp;System.out.println("Hello&nbsp;world!");<br/>&nbsp;&nbsp;//&nbsp;98&nbsp;copies&nbsp;omitted&nbsp;for&nbsp;brevity.<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'AvoidThrowingNullPointerException', :description => 'Avoid throwing a NullPointerException - it\'s confusing because most people will assume that the<br/> virtual machine threw it.  Consider using an IllegalArgumentException instead; this will be<br/> clearly seen as a programmer initiated exception.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;throw&nbsp;new&nbsp;NullPointerException();<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'WhileLoopsMustUseBraces', :description => 'Avoid using \'while\' statements without using curly braces',  :example => 'public&nbsp;void&nbsp;doSomething()&nbsp;{<br/>&nbsp;&nbsp;while&nbsp;(true)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x++;<br/>}'
    StyleCheck.create :name => 'UseArraysAsList', :description => 'The class java.util.Arrays has a "asList" method that<br/>   should be use when you want to create a new List from<br/>   an array of objects. It is faster than executing a loop to<br/>   cpy all the elements of the array one by one',  :example => 'public&nbsp;class&nbsp;Test&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;foo(Integer[]&nbsp;ints)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;could&nbsp;just&nbsp;use&nbsp;Arrays.asList(ints)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;l=&nbsp;new&nbsp;ArrayList(10);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i=0;&nbsp;i<&nbsp;100;&nbsp;i++)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.add(ints[i]);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i=0;&nbsp;i<&nbsp;100;&nbsp;i++)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.add(a[i].toString());&nbsp;//&nbsp;won\'t&nbsp;trigger&nbsp;the&nbsp;rule<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;}'
    StyleCheck.create :name => 'DoubleCheckedLocking', :description => 'Partially created objects can be returned by the Double Checked Locking pattern when used in Java.<br/>An optimizing JRE may assign a reference to the baz variable before it creates the object the<br/>  reference is intended to point to.  For more details see http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;Object&nbsp;baz;<br/>&nbsp;&nbsp;Object&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;if(baz&nbsp;==&nbsp;null)&nbsp;{&nbsp;//baz&nbsp;may&nbsp;be&nbsp;non-null&nbsp;yet&nbsp;not&nbsp;fully&nbsp;created<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized(this){<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(baz&nbsp;==&nbsp;null){<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baz&nbsp;=&nbsp;new&nbsp;Object();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;baz;<br/>&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'ReturnFromFinallyBlock', :description => 'Avoid returning from a finally block - this can discard exceptions.',  :example => 'public&nbsp;class&nbsp;Bar&nbsp;{<br/>&nbsp;public&nbsp;String&nbsp;foo()&nbsp;{<br/>&nbsp;&nbsp;try&nbsp;{<br/>&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;Exception(&nbsp;"My&nbsp;Exception"&nbsp;);<br/>&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;throw&nbsp;e;<br/>&nbsp;&nbsp;}&nbsp;finally&nbsp;{<br/>&nbsp;&nbsp;&nbsp;return&nbsp;"A.&nbsp;O.&nbsp;K.";&nbsp;//&nbsp;Very&nbsp;bad.<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'UnusedPrivateMethod', :description => 'Unused Private Method detects when a private method is declared but is unused.',  :example => 'public&nbsp;class&nbsp;Something&nbsp;{<br/>&nbsp;private&nbsp;void&nbsp;foo()&nbsp;{}&nbsp;//&nbsp;unused<br/>}'
    StyleCheck.create :name => 'AvoidProtectedFieldInFinalClass', :description => 'Do not use protected fields in final classes since they cannot be subclassed.<br/>Clarify your intent by using private or package access modifiers instead.',  :example => 'public&nbsp;final&nbsp;class&nbsp;Bar&nbsp;{<br/>&nbsp;private&nbsp;int&nbsp;x;<br/>&nbsp;protected&nbsp;int&nbsp;y;&nbsp;&nbsp;//&nbsp;<--&nbsp;Bar&nbsp;cannot&nbsp;be&nbsp;subclassed,&nbsp;so&nbsp;is&nbsp;y&nbsp;really&nbsp;private&nbsp;or&nbsp;package&nbsp;visible???<br/>&nbsp;Bar()&nbsp;{}<br/>}'
    StyleCheck.create :name => 'MisplacedNullCheck', :description => 'The null check here is misplaced. if the variable is null you\'ll get a NullPointerException.<br/>    Either the check is useless (the variable will never  be "null") or it\'s incorrect.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;if&nbsp;(a.equals("hi")&nbsp;&&&nbsp;a&nbsp;!=&nbsp;null)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'DefaultLabelNotLastInSwitchStmt', :description => 'By convention, the default label should be the last label in a switch statement.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;void&nbsp;bar(int&nbsp;a)&nbsp;{<br/>&nbsp;&nbsp;switch&nbsp;(a)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;case&nbsp;1:&nbsp;&nbsp;//&nbsp;do&nbsp;something<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>&nbsp;&nbsp;&nbsp;default:&nbsp;&nbsp;//&nbsp;the&nbsp;default&nbsp;case&nbsp;should&nbsp;be&nbsp;last,&nbsp;by&nbsp;convention<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>&nbsp;&nbsp;&nbsp;case&nbsp;2:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'SwitchStmtsShouldHaveDefault', :description => 'Switch statements should have a default label.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;int&nbsp;x&nbsp;=&nbsp;2;<br/>&nbsp;&nbsp;switch&nbsp;(x)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;case&nbsp;2:&nbsp;int&nbsp;j&nbsp;=&nbsp;8;<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'CloseResource', :description => 'Ensure that resources (like Connection, Statement, and ResultSet objects) are always closed after use',  :example => 'public&nbsp;class&nbsp;Bar&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;foo()&nbsp;{<br/>&nbsp;&nbsp;Connection&nbsp;c&nbsp;=&nbsp;pool.getConnection();<br/>&nbsp;&nbsp;try&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;stuff<br/>&nbsp;&nbsp;}&nbsp;catch&nbsp;(SQLException&nbsp;ex)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;handle&nbsp;exception<br/>&nbsp;&nbsp;}&nbsp;finally&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;oops,&nbsp;should&nbsp;close&nbsp;the&nbsp;connection&nbsp;using&nbsp;\'close\'!<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;c.close();<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'UncommentedEmptyConstructor', :description => 'Uncommented Empty Constructor finds instances where a constructor does not<br/>contain statements, but there is no comment. By explicitly commenting empty<br/>constructors it is easier to distinguish between intentional (commented)<br/>and unintentional empty constructors.',  :example => 'public&nbsp;Foo()&nbsp;{<br/>&nbsp;&nbsp;super();<br/>}'
    StyleCheck.create :name => 'FinalizeDoesNotCallSuperFinalize', :description => 'If the finalize() is implemented, its last action should be to call super.finalize',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;&nbsp;protected&nbsp;void&nbsp;finalize()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;something();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;neglected&nbsp;to&nbsp;call&nbsp;super.finalize()<br/>&nbsp;&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'BrokenNullCheck', :description => 'The null check is broken since it will throw a Nullpointer itself. <br/>The reason is that a method is called on the object when it is null. <br/>It is likely that you used || instead of && or vice versa.',  :example => 'class&nbsp;Foo&nbsp;{<br/>&nbsp;String&nbsp;munge(String&nbsp;string)&nbsp;{<br/>&nbsp;&nbsp;//&nbsp;should&nbsp;be&nbsp;&&<br/>&nbsp;&nbsp;if&nbsp;(string!=null&nbsp;||&nbsp;!string.equals(""))<br/>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;string;<br/>&nbsp;&nbsp;//&nbsp;should&nbsp;be&nbsp;||<br/>&nbsp;&nbsp;if&nbsp;(string==null&nbsp;&&&nbsp;string.equals(""))<br/>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;string;<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'FinalizeOverloaded', :description => 'Methods named finalize() should not have parameters.  It is<br/>confusing and probably a bug to overload finalize().  It will<br/>not be called by the VM.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;&nbsp;//&nbsp;this&nbsp;is&nbsp;confusing&nbsp;and&nbsp;probably&nbsp;a&nbsp;bug<br/>&nbsp;&nbsp;&nbsp;protected&nbsp;void&nbsp;finalize(int&nbsp;a)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'ExcessiveImports', :description => 'A high number of imports can indicate a high degree of coupling within<br/>an object. Rule counts the number of unique imports and reports a violation<br/>if the count is above the user defined threshold.',  :example => 'import&nbsp;blah.blah.Baz;<br/>import&nbsp;blah.blah.Bif;<br/>//&nbsp;18&nbsp;others&nbsp;from&nbsp;the&nbsp;same&nbsp;package&nbsp;elided<br/>public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;doWork()&nbsp;{}<br/>}'
    StyleCheck.create :name => 'CouplingBetweenObjects', :description => 'Rule counts unique attributes, local variables and return types within an object. An amount<br/> higher than specified threshold can indicate a high degree of coupling.',  :example => 'import&nbsp;com.Blah;<br/>import&nbsp;org.Bar;<br/>import&nbsp;org.Bardo;<br/>public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;private&nbsp;Blah&nbsp;var1;<br/>&nbsp;private&nbsp;Bar&nbsp;var2;<br/>&nbsp;//followed&nbsp;by&nbsp;many&nbsp;imports&nbsp;of&nbsp;unique&nbsp;objects<br/>&nbsp;void&nbsp;ObjectC&nbsp;doWork()&nbsp;{<br/>&nbsp;&nbsp;Bardo&nbsp;var55;<br/>&nbsp;&nbsp;ObjectA&nbsp;var44;<br/>&nbsp;&nbsp;ObjectZ&nbsp;var93;<br/>&nbsp;&nbsp;return&nbsp;something;<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'SimplifyConditional', :description => 'No need to check for null before an instanceof; the instanceof keyword returns false when given a null argument.',  :example => 'class&nbsp;Foo&nbsp;{<br/>&nbsp;void&nbsp;bar(Object&nbsp;x)&nbsp;{<br/>&nbsp;&nbsp;if&nbsp;(x&nbsp;!=&nbsp;null&nbsp;&&&nbsp;x&nbsp;instanceof&nbsp;Bar)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;//&nbsp;just&nbsp;drop&nbsp;the&nbsp;"x&nbsp;!=&nbsp;null"&nbsp;check<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'CollapsibleIfStatements', :description => 'Sometimes two \'if\' statements can be consolidated by separating their conditions with a boolean short-circuit operator.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;if&nbsp;(x)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;if&nbsp;(y)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;stuff<br/>&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'IfElseStmtsMustUseBraces', :description => 'Avoid using if..else statements without using curly braces',  :example => 'public&nbsp;void&nbsp;doSomething()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;//&nbsp;this&nbsp;is&nbsp;OK<br/>&nbsp;&nbsp;&nbsp;if&nbsp;(foo)&nbsp;x++;<br/>&nbsp;&nbsp;&nbsp;//&nbsp;but&nbsp;this&nbsp;is&nbsp;not<br/>&nbsp;&nbsp;&nbsp;if&nbsp;(foo)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x=x+1;<br/>&nbsp;&nbsp;&nbsp;else<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x=x-1;<br/>&nbsp;}'
    StyleCheck.create :name => 'EmptyFinalizer', :description => 'If the finalize() method is empty, then it does not need to exist.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;&nbsp;protected&nbsp;void&nbsp;finalize()&nbsp;{}<br/>}'
    StyleCheck.create :name => 'NonThreadSafeSingleton', :description => 'Non-thread safe singletons can result in bad state changes. If possible,<br/>get rid of static singletons by directly instantiating the object. Static<br/>singletons are usually not needed as only a single instance exists anyway.<br/>Other possible fixes are to synchronize the entire method or to use an<br/>initialize-on-demand holder class (do not use the double-check idiom).<br/><br/>See Effective Java, item 48.',  :example => 'private&nbsp;static&nbsp;Foo&nbsp;foo&nbsp;=&nbsp;null;<br/><br/>//multiple&nbsp;simultaneous&nbsp;callers&nbsp;may&nbsp;see&nbsp;partially&nbsp;initialized&nbsp;objects<br/>public&nbsp;static&nbsp;Foo&nbsp;getFoo()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(foo==null)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foo&nbsp;=&nbsp;new&nbsp;Foo();<br/>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;foo;<br/>}'
    StyleCheck.create :name => 'VariableNamingConventions', :description => 'A variable naming conventions rule - customize this to your liking.  Currently, it<br/> checks that final variables should be all caps and non-final variables<br/> should not include underscores.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;static&nbsp;final&nbsp;int&nbsp;MY_NUM&nbsp;=&nbsp;0;<br/>&nbsp;public&nbsp;String&nbsp;myTest&nbsp;=&nbsp;"";<br/>&nbsp;DataModule&nbsp;dmTest&nbsp;=&nbsp;new&nbsp;DataModule();<br/>}'
    StyleCheck.create :name => 'InefficientEmptyStringCheck', :description => 'String.trim().length() is an inefficient way to check if a String is really empty, as it <br/>	   creates a new String object just to check its size. Looping through a string, checking Character.isWhitespace()<br/>	   on each character and returning false if a non-whitespace character is found is preferable',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;bar(String&nbsp;string)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(string&nbsp;!=&nbsp;null&nbsp;&&&nbsp;string.trim().size()&nbsp;>&nbsp;0)&nbsp;{&nbsp;<br/>		&nbsp;&nbsp;&nbsp;&nbsp;doSomething();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'ForLoopShouldBeWhileLoop', :description => 'Some for loops can be simplified to while loops - this makes them more concise.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;for&nbsp;(;true;)&nbsp;true;&nbsp;//&nbsp;No&nbsp;Init&nbsp;or&nbsp;Update&nbsp;part,&nbsp;may&nbsp;as&nbsp;well&nbsp;be:&nbsp;while&nbsp;(true)<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'JumbledIncrementer', :description => 'Avoid jumbled loop incrementers - it\'s usually a mistake, and it\'s confusing even if it\'s what\'s intended.',  :example => 'public&nbsp;class&nbsp;JumbledIncrementerRule1&nbsp;{<br/>&nbsp;&nbsp;public&nbsp;void&nbsp;foo()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;<&nbsp;10;&nbsp;i++)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;k&nbsp;=&nbsp;0;&nbsp;k&nbsp;<&nbsp;20;&nbsp;i++)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Hello");<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;}<br/>&nbsp;}'
    StyleCheck.create :name => 'EmptyStaticInitializer', :description => 'An empty static initializer was found.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;static&nbsp;{<br/>&nbsp;&nbsp;//&nbsp;empty<br/>&nbsp;}<br/>&nbsp;}'
    StyleCheck.create :name => 'InstantiationToGetClass', :description => 'Avoid instantiating an object just to call getClass() on it; use the .class public member instead',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;//&nbsp;Replace&nbsp;this<br/>&nbsp;Class&nbsp;c&nbsp;=&nbsp;new&nbsp;String().getClass();<br/>&nbsp;//&nbsp;with&nbsp;this:<br/>&nbsp;Class&nbsp;c&nbsp;=&nbsp;String.class;<br/>}'
    StyleCheck.create :name => 'FinalFieldCouldBeStatic', :description => 'If a final field is assigned to a compile-time constant, it could be<br/>made static, thus saving overhead in each object',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;final&nbsp;int&nbsp;BAR&nbsp;=&nbsp;42;&nbsp;//&nbsp;this&nbsp;could&nbsp;be&nbsp;static&nbsp;and&nbsp;save&nbsp;some&nbsp;space<br/>}'
    StyleCheck.create :name => 'UseSingleton', :description => 'If you have a class that has nothing but static methods, consider making it a Singleton.<br/>Note that this doesn\'t apply to abstract classes, since their subclasses may<br/>well include non-static methods.  Also, if you want this class to be a Singleton,<br/>remember to add a private constructor to prevent instantiation.',  :example => 'public&nbsp;class&nbsp;MaybeASingleton&nbsp;{<br/>&nbsp;public&nbsp;static&nbsp;void&nbsp;foo()&nbsp;{}<br/>&nbsp;public&nbsp;static&nbsp;void&nbsp;bar()&nbsp;{}<br/>}'
    StyleCheck.create :name => 'AvoidCatchingNPE', :description => 'Code should never throw NPE under normal circumstances.  A catch block may hide the original error, causing other more subtle errors in its wake.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;try&nbsp;{<br/>&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something<br/>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;catch&nbsp;(NullPointerException&nbsp;npe)&nbsp;{<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'UncommentedEmptyMethod', :description => 'Uncommented Empty Method finds instances where a method does not contain<br/>statements, but there is no comment. By explicitly commenting empty methods<br/>it is easier to distinguish between intentional (commented) and unintentional<br/>empty methods.',  :example => 'public&nbsp;void&nbsp;doSomething()&nbsp;{<br/>}'
    StyleCheck.create :name => 'StringInstantiation', :description => 'Avoid instantiating String objects; this is usually unnecessary.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;private&nbsp;String&nbsp;bar&nbsp;=&nbsp;new&nbsp;String("bar");&nbsp;//&nbsp;just&nbsp;do&nbsp;a&nbsp;String&nbsp;bar&nbsp;=&nbsp;"bar";<br/>}'
    StyleCheck.create :name => 'SuspiciousConstantFieldName', :description => 'A field name is all in uppercase characters, which in Sun\'s Java naming<br/>conventions indicate a constant. However, the field is not final.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;//&nbsp;this&nbsp;is&nbsp;bad,&nbsp;since&nbsp;someone&nbsp;could&nbsp;accidentally<br/>&nbsp;//&nbsp;do&nbsp;PI&nbsp;=&nbsp;2.71828;&nbsp;which&nbsp;is&nbsp;actualy&nbsp;e<br/>&nbsp;//&nbsp;final&nbsp;double&nbsp;PI&nbsp;=&nbsp;3.16;&nbsp;is&nbsp;ok<br/>&nbsp;double&nbsp;PI&nbsp;=&nbsp;3.16;<br/>}'
    StyleCheck.create :name => 'ExcessiveClassLength', :description => 'Long Class files are indications that the class may be trying to<br/>do too much.  Try to break it down, and reduce the size to something<br/>manageable.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;public&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;1000&nbsp;lines&nbsp;of&nbsp;code<br/>&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'ShortMethodName', :description => 'Detects when very short method names are used.',  :example => 'public&nbsp;class&nbsp;ShortMethod&nbsp;{<br/>&nbsp;&nbsp;public&nbsp;void&nbsp;a(&nbsp;int&nbsp;i&nbsp;)&nbsp;{&nbsp;//&nbsp;Violation<br/>&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'AppendCharacterWithChar', :description => 'Avoid concatenating characters as strings in StringBuffer.append',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;StringBuffer&nbsp;sb=new&nbsp;StringBuffer();<br/>&nbsp;&nbsp;//&nbsp;Avoid&nbsp;this<br/>&nbsp;&nbsp;sb.append("a");<br/><br/>&nbsp;&nbsp;//&nbsp;use&nbsp;instead&nbsp;something&nbsp;like&nbsp;this<br/>&nbsp;&nbsp;StringBuffer&nbsp;sb=new&nbsp;StringBuffer();<br/>&nbsp;&nbsp;sb.append(\'a\');<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'AvoidInstantiatingObjectsInLoops', :description => 'Detects when a new object is created inside a loop',  :example => 'public&nbsp;class&nbsp;Something&nbsp;{<br/>&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(&nbsp;String&nbsp;as[]&nbsp;)&nbsp;{&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;<&nbsp;10;&nbsp;i++)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Foo&nbsp;f&nbsp;=&nbsp;new&nbsp;Foo();&nbsp;//Avoid&nbsp;this&nbsp;whenever&nbsp;you&nbsp;can&nbsp;it\'s&nbsp;really&nbsp;expensive<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'CompareObjectsWithEquals', :description => 'Use equals() to compare object references; avoid comparing them with ==.',  :example => 'class&nbsp;Foo&nbsp;{<br/>&nbsp;boolean&nbsp;bar(String&nbsp;a,&nbsp;String&nbsp;b)&nbsp;{<br/>&nbsp;&nbsp;return&nbsp;a&nbsp;==&nbsp;b;<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'EqualsNull', :description => 'Newbie programmers sometimes get the comparison concepts confused<br/>and use equals() to compare to null.',  :example => 'class&nbsp;Bar&nbsp;{<br/>&nbsp;&nbsp;&nbsp;void&nbsp;foo()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;x&nbsp;=&nbsp;"foo";<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(x.equals(null))&nbsp;{&nbsp;//&nbsp;bad!<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doSomething();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'UnnecessaryWrapperObjectCreation', :description => 'Parsing method should be called directy instead.',  :example => 'public&nbsp;int&nbsp;convert(String&nbsp;s)&nbsp;{<br/>&nbsp;&nbsp;int&nbsp;i,&nbsp;i2;<br/><br/>&nbsp;&nbsp;i&nbsp;=&nbsp;Integer.valueOf(s).intValue();&nbsp;//&nbsp;this&nbsp;wastes&nbsp;an&nbsp;object<br/>&nbsp;&nbsp;i&nbsp;=&nbsp;Integer.parseInt(s);&nbsp;//&nbsp;this&nbsp;is&nbsp;better<br/><br/>&nbsp;&nbsp;i2&nbsp;=&nbsp;Integer.valueOf(i).intValue();&nbsp;//&nbsp;this&nbsp;wastes&nbsp;an&nbsp;object<br/>&nbsp;&nbsp;i2&nbsp;=&nbsp;i;&nbsp;//&nbsp;this&nbsp;is&nbsp;better<br/><br/>&nbsp;&nbsp;return&nbsp;i2;<br/>}'
    StyleCheck.create :name => 'AvoidThreadGroup', :description => 'Avoid using ThreadGroup; although it is intended to be used in a threaded environment<br/> it contains methods that are not thread safe.',  :example => 'public&nbsp;class&nbsp;Bar&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;buz()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThreadGroup&nbsp;tg&nbsp;=&nbsp;new&nbsp;ThreadGroup("My&nbsp;threadgroup")&nbsp;;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tg&nbsp;=&nbsp;new&nbsp;ThreadGroup(tg,&nbsp;"my&nbsp;thread&nbsp;group");<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tg&nbsp;=&nbsp;Thread.currentThread().getThreadGroup();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tg&nbsp;=&nbsp;System.getSecurityManager().getThreadGroup();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}'
    StyleCheck.create :name => 'SimplifyStartsWith', :description => 'Since it passes in a literal of length 1, this call to String.startsWith can be rewritten using String.charAt(0) to save some time.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;boolean&nbsp;checkIt(String&nbsp;x)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;x.startsWith("a");<br/>&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'SimplifyBooleanReturns', :description => 'Avoid unnecessary if..then..else statements when returning a boolean',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;private&nbsp;int&nbsp;bar&nbsp;=2;<br/>&nbsp;&nbsp;public&nbsp;boolean&nbsp;isBarEqualsTo(int&nbsp;x)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;this&nbsp;bit&nbsp;of&nbsp;code<br/>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(bar&nbsp;==&nbsp;x)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;can&nbsp;be&nbsp;replaced&nbsp;with&nbsp;a&nbsp;simple<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;return&nbsp;bar&nbsp;==&nbsp;x;<br/>&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'UseNotifyAllInsteadOfNotify', :description => 'Thread.notify() awakens a thread monitoring the object. If more than one thread is monitoring, then only<br/>one is chosen.  The thread chosen is arbitrary; thus it\'s usually safer to call notifyAll() instead.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;x.notify();<br/>&nbsp;&nbsp;//&nbsp;If&nbsp;many&nbsp;threads&nbsp;are&nbsp;monitoring&nbsp;x,&nbsp;only&nbsp;one&nbsp;(and&nbsp;you&nbsp;won\'t&nbsp;know&nbsp;which)&nbsp;will&nbsp;be&nbsp;notified.<br/>&nbsp;&nbsp;//&nbsp;use&nbsp;instead:<br/>&nbsp;&nbsp;x.notifyAll();<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'FinalizeOnlyCallsSuperFinalize', :description => 'If the finalize() is implemented, it should do something besides just calling<br/>super.finalize().',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;&nbsp;protected&nbsp;void&nbsp;finalize()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.finalize();<br/>&nbsp;&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'SimplifyBooleanExpressions', :description => 'Avoid unnecessary comparisons in boolean expressions - this makes simple code seem complicated.',  :example => 'public&nbsp;class&nbsp;Bar&nbsp;{<br/>&nbsp;//&nbsp;can&nbsp;be&nbsp;simplified&nbsp;to<br/>&nbsp;//&nbsp;bar&nbsp;=&nbsp;isFoo();<br/>&nbsp;private&nbsp;boolean&nbsp;bar&nbsp;=&nbsp;(isFoo()&nbsp;==&nbsp;true);<br/><br/>&nbsp;public&nbsp;isFoo()&nbsp;{&nbsp;return&nbsp;false;}<br/>}'
    StyleCheck.create :name => 'MisleadingVariableName', :description => 'Detects when a non-field has a name starting with \'m_\'.  This usually<br/>indicates a field and thus is confusing.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;m_foo;&nbsp;//&nbsp;OK<br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;bar(String&nbsp;m_baz)&nbsp;{&nbsp;&nbsp;//&nbsp;Bad<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;m_boz&nbsp;=&nbsp;42;&nbsp;//&nbsp;Bad<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;}'
    StyleCheck.create :name => 'ConstructorCallsOverridableMethod', :description => 'Calling overridable methods during construction poses a risk of invoking methods on an<br/>incompletely constructed object.  This situation can be difficult to discern.<br/>It may leave the sub-class unable to construct its superclass or forced to<br/>replicate the construction process completely within itself, losing the ability to call<br/>super().  If the default constructor contains a call to an overridable method,<br/>the subclass may be completely uninstantiable.   Note that this includes method calls<br/>throughout the control flow graph - i.e., if a constructor Foo() calls a private method<br/>bar() that calls a public method buz(), there\'s a problem.',  :example => 'public&nbsp;class&nbsp;SeniorClass&nbsp;{<br/>&nbsp;&nbsp;public&nbsp;SeniorClass(){<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toString();&nbsp;//may&nbsp;throw&nbsp;NullPointerException&nbsp;if&nbsp;overridden<br/>&nbsp;&nbsp;}<br/>&nbsp;&nbsp;public&nbsp;String&nbsp;toString(){<br/>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"IAmSeniorClass";<br/>&nbsp;&nbsp;}<br/>}<br/>public&nbsp;class&nbsp;JuniorClass&nbsp;extends&nbsp;SeniorClass&nbsp;{<br/>&nbsp;&nbsp;private&nbsp;String&nbsp;name;<br/>&nbsp;&nbsp;public&nbsp;JuniorClass(){<br/>&nbsp;&nbsp;&nbsp;&nbsp;super();&nbsp;//Automatic&nbsp;call&nbsp;leads&nbsp;to&nbsp;NullPointerException<br/>&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;"JuniorClass";<br/>&nbsp;&nbsp;}<br/>&nbsp;&nbsp;public&nbsp;String&nbsp;toString(){<br/>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;name.toUpperCase();<br/>&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'EmptyIfStmt', :description => 'Empty If Statement finds instances where a condition is checked but nothing is done about it.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;void&nbsp;bar(int&nbsp;x)&nbsp;{<br/>&nbsp;&nbsp;if&nbsp;(x&nbsp;==&nbsp;0)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;//&nbsp;empty!<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'AvoidInstanceofChecksInCatchClause', :description => 'Each caught exception type should be handled in its own catch clause.',  :example => 'try&nbsp;{&nbsp;//&nbsp;Avoid&nbsp;this<br/>&nbsp;//&nbsp;do&nbsp;something<br/>}&nbsp;catch&nbsp;(Exception&nbsp;ee)&nbsp;{<br/>&nbsp;if&nbsp;(ee&nbsp;instanceof&nbsp;IOException)&nbsp;{<br/>&nbsp;&nbsp;cleanup();<br/>&nbsp;}<br/>}<br/>try&nbsp;{&nbsp;&nbsp;//&nbsp;Prefer&nbsp;this:<br/>&nbsp;//&nbsp;do&nbsp;something<br/>}&nbsp;catch&nbsp;(IOException&nbsp;ee)&nbsp;{<br/>&nbsp;cleanup();<br/>}'
    StyleCheck.create :name => 'EmptySynchronizedBlock', :description => 'Avoid empty synchronized blocks - they\'re useless.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;synchronized&nbsp;(this)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;//&nbsp;empty!<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'UnnecessaryCaseChange', :description => 'Using equalsIgnoreCase() is faster than using toUpperCase/toLowerCase().equals()',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;public&nbsp;boolean&nbsp;bar(String&nbsp;buz)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;should&nbsp;be&nbsp;buz.equalsIgnoreCase("baz")<br/>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;buz.toUpperCase().equals("baz");<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;another&nbsp;unnecessary&nbsp;toUpperCase()<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;return&nbsp;buz.toUpperCase().equalsIgnoreCase("baz");<br/>&nbsp;&nbsp;}<br/>&nbsp;}'
    StyleCheck.create :name => 'EmptyWhileStmt', :description => 'Empty While Statement finds all instances where a while statement<br/>does nothing.  If it is a timing loop, then you should use Thread.sleep() for it; if<br/>it\'s a while loop that does a lot in the exit expression, rewrite it to make it clearer.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;void&nbsp;bar(int&nbsp;a,&nbsp;int&nbsp;b)&nbsp;{<br/>&nbsp;&nbsp;while&nbsp;(a&nbsp;==&nbsp;b)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;//&nbsp;empty!<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'AvoidRethrowingException', :description => 'Catch blocks that merely rethrow a caught exception only add to code size and runtime complexity.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something<br/>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;catch&nbsp;(SomeException&nbsp;se)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;se;<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;}'
    StyleCheck.create :name => 'UseIndexOfChar', :description => 'Use String.indexOf(char) when checking for the index of a single character; it\'s faster.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;String&nbsp;s&nbsp;=&nbsp;"hello&nbsp;world";<br/>&nbsp;&nbsp;//&nbsp;avoid&nbsp;this<br/>&nbsp;&nbsp;if&nbsp;(s.indexOf("d")&nbsp;{}<br/>&nbsp;&nbsp;//&nbsp;instead&nbsp;do&nbsp;this<br/>&nbsp;&nbsp;if&nbsp;(s.indexOf(\'d\')&nbsp;{}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'AvoidArrayLoops', :description => 'Instead of copying data between two arrays, use<br/>    System.arrayCopy method',  :example => 'public&nbsp;class&nbsp;Test&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;int[]&nbsp;a&nbsp;=&nbsp;new&nbsp;int[10];<br/>&nbsp;&nbsp;int[]&nbsp;b&nbsp;=&nbsp;new&nbsp;int[10];<br/>&nbsp;&nbsp;for&nbsp;(int&nbsp;i=0;i<10;i++)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;b[i]=a[i];<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;this&nbsp;will&nbsp;trigger&nbsp;the&nbsp;rule<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i=0;i<10;i++)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b[i]=a[c[i]];<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}'
    StyleCheck.create :name => 'UnnecessaryConversionTemporary', :description => 'Avoid unnecessary temporaries when converting primitives to Strings',  :example => 'public&nbsp;String&nbsp;convert(int&nbsp;x)&nbsp;{<br/>&nbsp;&nbsp;//&nbsp;this&nbsp;wastes&nbsp;an&nbsp;object<br/>&nbsp;&nbsp;String&nbsp;foo&nbsp;=&nbsp;new&nbsp;Integer(x).toString();<br/>&nbsp;&nbsp;//&nbsp;this&nbsp;is&nbsp;better<br/>&nbsp;&nbsp;return&nbsp;Integer.toString(x);<br/>}'
    StyleCheck.create :name => 'MethodWithSameNameAsEnclosingClass', :description => 'Non-constructor methods should not have the same name as the enclosing class.',  :example => 'public&nbsp;class&nbsp;MyClass&nbsp;{<br/>&nbsp;//&nbsp;this&nbsp;is&nbsp;bad&nbsp;because&nbsp;it&nbsp;is&nbsp;a&nbsp;method<br/>&nbsp;public&nbsp;void&nbsp;MyClass()&nbsp;{}<br/>&nbsp;//&nbsp;this&nbsp;is&nbsp;OK&nbsp;because&nbsp;it&nbsp;is&nbsp;a&nbsp;constructor<br/>&nbsp;public&nbsp;MyClass()&nbsp;{}<br/>}'
    StyleCheck.create :name => 'OverrideBothEqualsAndHashcode', :description => 'Override both public boolean Object.equals(Object other), and public int Object.hashCode(), or override neither.  Even if you are inheriting a hashCode() from a parent class, consider implementing hashCode and explicitly delegating to your superclass.',  :example => '//&nbsp;this&nbsp;is&nbsp;bad<br/>public&nbsp;class&nbsp;Bar&nbsp;{<br/>&nbsp;&nbsp;public&nbsp;boolean&nbsp;equals(Object&nbsp;o)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;some&nbsp;comparison<br/>&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;and&nbsp;so&nbsp;is&nbsp;this<br/>public&nbsp;class&nbsp;Baz&nbsp;{<br/>&nbsp;&nbsp;public&nbsp;int&nbsp;hashCode()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;return&nbsp;some&nbsp;hash&nbsp;value<br/>&nbsp;&nbsp;}<br/>}<br/><br/>//&nbsp;this&nbsp;is&nbsp;OK<br/>public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;public&nbsp;boolean&nbsp;equals(Object&nbsp;other)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;some&nbsp;comparison<br/>&nbsp;&nbsp;}<br/>&nbsp;&nbsp;public&nbsp;int&nbsp;hashCode()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;return&nbsp;some&nbsp;hash&nbsp;value<br/>&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'ExcessiveParameterList', :description => 'Long parameter lists can indicate that a new object should be created to<br/> wrap the numerous parameters.  Basically, try to group the parameters together.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;addData(<br/>&nbsp;&nbsp;int&nbsp;p0,&nbsp;int&nbsp;p1,&nbsp;int&nbsp;p2,&nbsp;int&nbsp;p3,&nbsp;int&nbsp;p4,&nbsp;int&nbsp;p5,<br/>&nbsp;&nbsp;int&nbsp;p5,&nbsp;int&nbsp;p6,&nbsp;int&nbsp;p7,&nbsp;int&nbsp;p8,&nbsp;int&nbsp;p9,&nbsp;int&nbsp;p10)&nbsp;{<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'UnusedPrivateField', :description => 'Detects when a private field is declared and/or assigned a value, but not used.',  :example => 'public&nbsp;class&nbsp;Something&nbsp;{<br/>&nbsp;&nbsp;private&nbsp;static&nbsp;int&nbsp;FOO&nbsp;=&nbsp;2;&nbsp;//&nbsp;Unused<br/>&nbsp;&nbsp;private&nbsp;int&nbsp;i&nbsp;=&nbsp;5;&nbsp;//&nbsp;Unused<br/>&nbsp;&nbsp;private&nbsp;int&nbsp;j&nbsp;=&nbsp;6;<br/>&nbsp;&nbsp;public&nbsp;int&nbsp;addOne()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;j++;<br/>&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'ForLoopsMustUseBraces', :description => 'Avoid using \'for\' statements without using curly braces',  :example => 'public&nbsp;void&nbsp;foo()&nbsp;{<br/>&nbsp;for&nbsp;(int&nbsp;i=0;&nbsp;i<42;i++)<br/>&nbsp;&nbsp;&nbsp;foo();<br/>}'
    StyleCheck.create :name => 'PositionLiteralsFirstInComparisons', :description => 'Position literals first in String comparisons - that way if the String is null you won\'t get a NullPointerException, it\'ll just return false.',  :example => 'class&nbsp;Foo&nbsp;{<br/>&nbsp;boolean&nbsp;bar(String&nbsp;x)&nbsp;{<br/>&nbsp;&nbsp;return&nbsp;x.equals("2");&nbsp;//&nbsp;should&nbsp;be&nbsp;"2".equals(x)<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'OptimizableToArrayCall', :description => 'A call to Collection.toArray can use the Collection\'s size vs an empty Array of the desired type.',  :example => 'class&nbsp;Foo&nbsp;{<br/>&nbsp;void&nbsp;bar(Collection&nbsp;x)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;//&nbsp;A&nbsp;bit&nbsp;inefficient<br/>&nbsp;&nbsp;&nbsp;x.toArray(new&nbsp;Foo[0]);<br/>&nbsp;&nbsp;&nbsp;//&nbsp;Much&nbsp;better;&nbsp;this&nbsp;one&nbsp;sizes&nbsp;the&nbsp;destination&nbsp;array,&nbsp;avoiding<br/>&nbsp;&nbsp;&nbsp;//&nbsp;a&nbsp;reflection&nbsp;call&nbsp;in&nbsp;some&nbsp;Collection&nbsp;implementations<br/>&nbsp;&nbsp;&nbsp;x.toArray(new&nbsp;Foo[x.size()]);<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'AvoidCallingFinalize', :description => 'Object.finalize() is called by the garbage collector on an object when garbage collection determines<br/>that there are no more references to the object.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;void&nbsp;foo()&nbsp;{<br/>&nbsp;&nbsp;Bar&nbsp;b&nbsp;=&nbsp;new&nbsp;Bar();<br/>&nbsp;&nbsp;b.finalize();<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'MethodArgumentCouldBeFinal', :description => 'A method argument that is never assigned can be declared final.',  :example => 'public&nbsp;void&nbsp;foo&nbsp;(String&nbsp;param)&nbsp;{<br/>&nbsp;&nbsp;//&nbsp;do&nbsp;stuff&nbsp;with&nbsp;param&nbsp;never&nbsp;assigning&nbsp;it<br/>&nbsp;&nbsp;//&nbsp;better:&nbsp;public&nbsp;void&nbsp;foo&nbsp;(final&nbsp;String&nbsp;param)&nbsp;{<br/>}', :bias => false
    StyleCheck.create :name => 'AvoidDollarSigns', :description => 'Avoid using dollar signs in variable/method/class/interface names.',  :example => 'public&nbsp;class&nbsp;Fo$o&nbsp;{&nbsp;&nbsp;//&nbsp;yikes!<br/>&nbsp;}'
    StyleCheck.create :name => 'ConsecutiveLiteralAppends', :description => 'Consecutively calling StringBuffer.append with String literals',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;private&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;StringBuffer&nbsp;buf&nbsp;=&nbsp;new&nbsp;StringBuffer();<br/>&nbsp;&nbsp;&nbsp;buf.append("Hello").append("&nbsp;").append("World");&nbsp;//bad<br/>&nbsp;&nbsp;&nbsp;buf.append("Hello&nbsp;World");//good<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'LooseCoupling', :description => 'Avoid using implementation types (i.e., HashSet); use the interface (i.e, Set) instead',  :example => 'import&nbsp;java.util.*;<br/>public&nbsp;class&nbsp;Bar&nbsp;{<br/>&nbsp;//&nbsp;Use&nbsp;List&nbsp;instead<br/>&nbsp;private&nbsp;ArrayList&nbsp;list&nbsp;=&nbsp;new&nbsp;ArrayList();<br/>&nbsp;//&nbsp;Use&nbsp;Set&nbsp;instead<br/>&nbsp;public&nbsp;HashSet&nbsp;getFoo()&nbsp;{<br/>&nbsp;&nbsp;return&nbsp;new&nbsp;HashSet();<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'UnconditionalIfStatement', :description => 'Do not use "if" statements that are always true or always false.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;close()&nbsp;{<br/>&nbsp;&nbsp;if&nbsp;(true)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...<br/>&nbsp;&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'NonStaticInitializer', :description => 'A nonstatic initializer block will be called any time a constructor<br/>is invoked (just prior to invoking the constructor).  While this<br/>is a valid language construct, it is rarely used and is confusing.',  :example => 'public&nbsp;class&nbsp;MyClass&nbsp;{<br/>&nbsp;//&nbsp;this&nbsp;block&nbsp;gets&nbsp;run&nbsp;before&nbsp;any&nbsp;call&nbsp;to&nbsp;a&nbsp;constructor<br/>&nbsp;{<br/>&nbsp;&nbsp;System.out.println("I&nbsp;am&nbsp;about&nbsp;to&nbsp;construct&nbsp;myself");<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'AssignmentToNonFinalStatic', :description => 'Identifies a possible unsafe usage of a static field.',  :example => 'public&nbsp;class&nbsp;StaticField&nbsp;{<br/>&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;x;<br/>&nbsp;&nbsp;&nbsp;public&nbsp;FinalFields(int&nbsp;y)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;y;&nbsp;//&nbsp;unsafe<br/>&nbsp;&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'EmptyStatementNotInLoop', :description => 'An empty statement (aka a semicolon by itself) that is not used<br/>as the sole body of a for loop or while loop is probably a bug.  It<br/>could also be a double semicolon, which is useless and should be<br/>removed.',  :example => 'public&nbsp;class&nbsp;MyClass&nbsp;{<br/>&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;doit()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;this&nbsp;is&nbsp;probably&nbsp;not&nbsp;what&nbsp;you&nbsp;meant&nbsp;to&nbsp;do<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;extra&nbsp;semicolon&nbsp;here&nbsp;this&nbsp;is&nbsp;not&nbsp;necessary<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("look&nbsp;at&nbsp;the&nbsp;extra&nbsp;semicolon");;<br/>&nbsp;&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'ClassCastExceptionWithToArray', :description => 'if you need to get an array of a class from your Collection,<br/>you should pass an array of the desidered class<br/>as the parameter of the toArray method. Otherwise you will get a<br/>ClassCastException.',  :example => 'import&nbsp;java.util.ArrayList;<br/>import&nbsp;java.util.Collection;<br/><br/>public&nbsp;class&nbsp;Test&nbsp;{<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collection&nbsp;c=new&nbsp;ArrayList();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;obj=new&nbsp;Integer(1);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.add(obj);<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;this&nbsp;would&nbsp;trigger&nbsp;the&nbsp;rule&nbsp;(and&nbsp;throw&nbsp;a&nbsp;ClassCastException<br/>if&nbsp;executed)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer[]&nbsp;a=(Integer&nbsp;[])c.toArray();<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;this&nbsp;wouldn\'t&nbsp;trigger&nbsp;the&nbsp;rule<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer[]&nbsp;b=(Integer&nbsp;[])c.toArray(new&nbsp;Integer[c.size()]);<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'ImmutableField', :description => 'Identifies private fields whose values never change once they are initialized either in the declaration of the field or by<br/>a constructor.  This aids in converting existing classes to immutable classes.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;private&nbsp;int&nbsp;x;&nbsp;//&nbsp;could&nbsp;be&nbsp;final<br/>&nbsp;&nbsp;public&nbsp;Foo()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;7;<br/>&nbsp;&nbsp;}<br/>&nbsp;&nbsp;public&nbsp;void&nbsp;foo()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;a&nbsp;=&nbsp;x&nbsp;+&nbsp;2;<br/>&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'MethodNamingConventions', :description => 'Method names should always begin with a lower case character, and should not contain underscores.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;fooStuff()&nbsp;{<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'InsufficientStringBufferDeclaration', :description => 'Failing to pre-size a StringBuffer properly could cause it to re-size many times <br/>during runtime. This rule checks the characters that are actually passed into<br/>StringBuffer.append(), but represents a best guess "worst case" scenario. An <br/>empty StringBuffer constructor initializes the object to 16 characters. This default <br/>is assumed if the length of the constructor can not be determined.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer&nbsp;bad&nbsp;=&nbsp;new&nbsp;StringBuffer();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bad.append("This&nbsp;is&nbsp;a&nbsp;long&nbsp;string,&nbsp;will&nbsp;exceed&nbsp;the&nbsp;default&nbsp;16&nbsp;characters");//bad&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer&nbsp;good&nbsp;=&nbsp;new&nbsp;StringBuffer(41);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;good.append("This&nbsp;is&nbsp;a&nbsp;long&nbsp;string,&nbsp;which&nbsp;is&nbsp;pre-sized");//good<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'UseStringBufferForStringAppends', :description => 'Finds usages of += for appending strings.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;String&nbsp;a;<br/>&nbsp;&nbsp;a&nbsp;=&nbsp;"foo";<br/>&nbsp;&nbsp;a&nbsp;+=&nbsp;"&nbsp;bar";<br/>&nbsp;&nbsp;//&nbsp;better&nbsp;would&nbsp;be:<br/>&nbsp;&nbsp;//&nbsp;StringBuffer&nbsp;a&nbsp;=&nbsp;new&nbsp;StringBuffer("foo");<br/>&nbsp;&nbsp;//&nbsp;a.append("&nbsp;bar);<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'SimpleDateFormatNeedsLocale', :description => 'Be sure to specify a Locale when creating a new instance of SimpleDateFormat.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;//&nbsp;Should&nbsp;specify&nbsp;Locale.US&nbsp;(or&nbsp;whatever)<br/>&nbsp;private&nbsp;SimpleDateFormat&nbsp;sdf&nbsp;=&nbsp;new&nbsp;SimpleDateFormat("pattern");<br/>}'
    StyleCheck.create :name => 'EmptyFinallyBlock', :description => 'Avoid empty finally blocks - these can be deleted.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;try&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;x=2;<br/>&nbsp;&nbsp;&nbsp;}&nbsp;finally&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;empty!<br/>&nbsp;&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'AvoidFieldNameMatchingMethodName', :description => 'It is somewhat confusing to have a field name with the same name as a method.<br/>While this is totally legal, having information (field) and actions (method) is<br/>not clear naming.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>	Object&nbsp;bar;<br/>	//&nbsp;bar&nbsp;is&nbsp;data&nbsp;or&nbsp;an&nbsp;action&nbsp;or&nbsp;both?<br/>	void&nbsp;bar()&nbsp;{<br/>	}<br/>}'
    StyleCheck.create :name => 'UnsynchronizedStaticDateFormatter', :description => 'SimpleDateFormat is not synchronized. Sun recomends separate format instances <br/>for each thread. If multiple threads must access a static formatter, the <br/>formatter must be synchronized either on method or block level.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;SimpleDateFormat&nbsp;sdf&nbsp;=&nbsp;new&nbsp;SimpleDateFormat();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sdf.format();&nbsp;//&nbsp;bad<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;synchronized&nbsp;void&nbsp;foo()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sdf.format();&nbsp;//&nbsp;good<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'ExceptionAsFlowControl', :description => 'Using Exceptions as flow control leads to GOTOish code.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;try&nbsp;{<br/>&nbsp;&nbsp;&nbsp;try&nbsp;{<br/>&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;WrapperException(e);<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;this&nbsp;is&nbsp;essentially&nbsp;a&nbsp;GOTO&nbsp;to&nbsp;the&nbsp;WrapperException&nbsp;catch&nbsp;block<br/>&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;}&nbsp;catch&nbsp;(WrapperException&nbsp;e)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;some&nbsp;more&nbsp;stuff<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'UseLocaleWithCaseConversions', :description => 'When doing a String.toLowerCase()/toUpperCase() call, use a Locale.  This avoids<br/>problems with certain locales, i.e. Turkish.',  :example => 'class&nbsp;Foo&nbsp;{<br/>&nbsp;//&nbsp;BAD<br/>&nbsp;if&nbsp;(x.toLowerCase().equals("list"))...<br/>&nbsp;/*<br/>&nbsp;This&nbsp;will&nbsp;not&nbsp;match&nbsp;"LIST"&nbsp;when&nbsp;in&nbsp;Turkish&nbsp;locale<br/>&nbsp;The&nbsp;above&nbsp;could&nbsp;be<br/>&nbsp;if&nbsp;(x.toLowerCase(Locale.US).equals("list"))&nbsp;...<br/>&nbsp;or&nbsp;simply<br/>&nbsp;if&nbsp;(x.equalsIgnoreCase("list"))&nbsp;...<br/>&nbsp;*/<br/>&nbsp;//&nbsp;GOOD<br/>&nbsp;String&nbsp;z&nbsp;=&nbsp;a.toLowerCase(Locale.EN);<br/>}'
    StyleCheck.create :name => 'MissingStaticMethodInNonInstantiatableClass', :description => 'A class that has private constructors and does not have any static methods or fields cannot be used.',  :example => '/*&nbsp;This&nbsp;class&nbsp;is&nbsp;unusable,&nbsp;since&nbsp;it&nbsp;cannot&nbsp;be<br/>&nbsp;instantiated&nbsp;(private&nbsp;constructor),<br/>&nbsp;and&nbsp;no&nbsp;static&nbsp;method&nbsp;can&nbsp;be&nbsp;called.<br/>&nbsp;*/<br/>public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;private&nbsp;Foo()&nbsp;{}<br/>&nbsp;void&nbsp;foo()&nbsp;{}<br/>}'
    StyleCheck.create :name => 'UseArrayListInsteadOfVector', :description => 'ArrayList is a much better Collection implementation than Vector.',  :example => 'public&nbsp;class&nbsp;SimpleTest&nbsp;extends&nbsp;TestCase&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;testX()&nbsp;{<br/>&nbsp;&nbsp;Collection&nbsp;c&nbsp;=&nbsp;new&nbsp;Vector();<br/>&nbsp;&nbsp;//&nbsp;This&nbsp;achieves&nbsp;the&nbsp;same&nbsp;with&nbsp;much&nbsp;better&nbsp;performance<br/>&nbsp;&nbsp;//&nbsp;Collection&nbsp;c&nbsp;=&nbsp;new&nbsp;ArrayList();<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'AvoidReassigningParameters', :description => 'Reassigning values to parameters is a questionable practice.  Use a temporary local variable instead.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;private&nbsp;void&nbsp;foo(String&nbsp;bar)&nbsp;{<br/>&nbsp;&nbsp;bar&nbsp;=&nbsp;"something&nbsp;else";<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'UnusedNullCheckInEquals', :description => 'After checking an object reference for null, you should invoke equals() on that object rather than passing it to another object\'s equals() method.',  :example => 'public&nbsp;class&nbsp;Test&nbsp;{<br/><br/>public&nbsp;String&nbsp;method1()&nbsp;{&nbsp;return&nbsp;"ok";}<br/>public&nbsp;String&nbsp;method2()&nbsp;{&nbsp;return&nbsp;null;}<br/><br/>public&nbsp;void&nbsp;method(String&nbsp;a)&nbsp;{<br/>String&nbsp;b;<br/>/*<br/>I&nbsp;don\'t&nbsp;know&nbsp;it&nbsp;method1()&nbsp;can&nbsp;be&nbsp;"null"<br/>but&nbsp;I&nbsp;know&nbsp;"a"&nbsp;is&nbsp;not&nbsp;null..<br/>I\'d&nbsp;better&nbsp;write&nbsp;a.equals(method1())<br/>*/<br/>if&nbsp;(a!=null&nbsp;&&&nbsp;method1().equals(a))&nbsp;{&nbsp;//&nbsp;will<br/>trigger&nbsp;the&nbsp;rule<br/>//whatever<br/>}<br/><br/>if&nbsp;(method1().equals(a)&nbsp;&&&nbsp;a&nbsp;!=&nbsp;null)&nbsp;{&nbsp;//<br/>won\'t&nbsp;trigger&nbsp;the&nbsp;rule<br/>//whatever<br/>}<br/><br/>if&nbsp;(a!=null&nbsp;&&&nbsp;method1().equals(b))&nbsp;{&nbsp;//&nbsp;won\'t<br/>trigger&nbsp;the&nbsp;rule<br/>//whatever<br/>}<br/><br/>if&nbsp;(a!=null&nbsp;&&&nbsp;"LITERAL".equals(a))&nbsp;{&nbsp;//&nbsp;won\'t<br/>trigger&nbsp;the&nbsp;rule<br/>//whatever<br/>}<br/><br/>if&nbsp;(a!=null&nbsp;&&&nbsp;!a.equals("go"))&nbsp;{&nbsp;//&nbsp;won\'t<br/>trigger&nbsp;the&nbsp;rule<br/>a=method2();<br/>if&nbsp;(method1().equals(a))&nbsp;{<br/>//whatever<br/>}<br/>}<br/>}<br/>}'
    StyleCheck.create :name => 'SignatureDeclareThrowsException', :description => 'It is unclear which exceptions that can be thrown from the methods.<br/>It might be difficult to document and understand the vague interfaces.<br/>Use either a class derived from RuntimeException or a checked exception.',  :example => 'public&nbsp;void&nbsp;methodThrowingException()&nbsp;throws&nbsp;Exception&nbsp;{<br/>}'
    StyleCheck.create :name => 'ClassNamingConventions', :description => 'Class names should always begin with an upper case character.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{}'
    StyleCheck.create :name => 'SuspiciousHashcodeMethodName', :description => 'The method name and return type are suspiciously close to hashCode(), which<br/>may mean you are intending to override the hashCode() method.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;int&nbsp;hashcode()&nbsp;{<br/>&nbsp;//&nbsp;oops,&nbsp;this&nbsp;probably&nbsp;was&nbsp;supposed&nbsp;to&nbsp;be&nbsp;hashCode<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'UselessOverridingMethod', :description => 'The overriding method merely calls the same method defined in a superclass',  :example => 'public&nbsp;String&nbsp;foo()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;super.foo();&nbsp;&nbsp;//Why&nbsp;bother&nbsp;overriding?<br/>}'
    StyleCheck.create :name => 'AvoidSynchronizedAtMethodLevel', :description => 'Method level synchronization can backfire when new code is added to the method.  Block-level<br/>  synchronization helps to ensure that only the code that needs synchronization gets it.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;//&nbsp;Try&nbsp;to&nbsp;avoid&nbsp;this<br/>&nbsp;synchronized&nbsp;void&nbsp;foo()&nbsp;{<br/>&nbsp;}<br/>&nbsp;//&nbsp;Prefer&nbsp;this:<br/>&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;synchronized(this)&nbsp;{<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'StringToString', :description => 'Avoid calling toString() on String objects; this is unnecessary',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;private&nbsp;String&nbsp;baz()&nbsp;{<br/>&nbsp;&nbsp;String&nbsp;bar&nbsp;=&nbsp;"howdy";<br/>&nbsp;&nbsp;return&nbsp;bar.toString();<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'AbstractNaming', :description => 'Abstract classes should be named \'AbstractXXX\'.',  :example => 'public&nbsp;abstract&nbsp;class&nbsp;Foo&nbsp;{&nbsp;//&nbsp;should&nbsp;be&nbsp;AbstractFoo<br/>}'
    StyleCheck.create :name => 'AvoidDuplicateLiterals', :description => 'Code containing duplicate String literals can usually be improved by declaring the String as a constant field.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;private&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;buz("Howdy");<br/>&nbsp;&nbsp;&nbsp;&nbsp;buz("Howdy");<br/>&nbsp;&nbsp;&nbsp;&nbsp;buz("Howdy");<br/>&nbsp;&nbsp;&nbsp;&nbsp;buz("Howdy");<br/>&nbsp;}<br/>&nbsp;private&nbsp;void&nbsp;buz(String&nbsp;x)&nbsp;{}<br/>}'
    StyleCheck.create :name => 'BooleanInstantiation', :description => 'Avoid instantiating Boolean objects; you can reference Boolean.TRUE, Boolean.FALSE, or call Boolean.valueOf() instead.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;Boolean&nbsp;bar&nbsp;=&nbsp;new&nbsp;Boolean("true");&nbsp;//&nbsp;just&nbsp;do&nbsp;a&nbsp;Boolean&nbsp;bar&nbsp;=&nbsp;Boolean.TRUE;<br/>&nbsp;Boolean&nbsp;buz&nbsp;=&nbsp;Boolean.valueOf(false);&nbsp;//&nbsp;just&nbsp;do&nbsp;a&nbsp;Boolean&nbsp;buz&nbsp;=&nbsp;Boolean.FALSE;<br/>}'
    StyleCheck.create :name => 'AvoidFieldNameMatchingTypeName', :description => 'It is somewhat confusing to have a field name matching the declaring class name.<br/>This proabably means that type and or field names could be more precise.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;extends&nbsp;Bar&nbsp;{<br/>&nbsp;//&nbsp;There\'s&nbsp;probably&nbsp;a&nbsp;better&nbsp;name&nbsp;for&nbsp;foo<br/>&nbsp;int&nbsp;foo;<br/>}'
    StyleCheck.create :name => 'CyclomaticComplexity', :description => 'Complexity is determined by the number of decision points in a method plus one for the<br/>method entry.  The decision points are \'if\', \'while\', \'for\', and \'case labels\'.  Generally,<br/>1-4 is low complexity, 5-7 indicates moderate complexity, 8-10 is high complexity,<br/> and 11+ is very high complexity.',  :example => '//&nbsp;Cyclomatic&nbsp;Complexity&nbsp;=&nbsp;12<br/>public&nbsp;class&nbsp;Foo&nbsp;{<br/>1&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;example()&nbsp;&nbsp;{<br/>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(a&nbsp;==&nbsp;b)&nbsp;&nbsp;{<br/>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(a1&nbsp;==&nbsp;b1)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fiddle();<br/>4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;a2&nbsp;==&nbsp;b2)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fiddle();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;else&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fiddle();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(c&nbsp;==&nbsp;d)&nbsp;{<br/>6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(c&nbsp;==&nbsp;d)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fiddle();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(e&nbsp;==&nbsp;f)&nbsp;{<br/>8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;n&nbsp;=&nbsp;0;&nbsp;n&nbsp;<&nbsp;h;&nbsp;n++)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fiddle();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(z)&nbsp;{<br/>9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;1:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fiddle();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;2:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fiddle();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;3:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fiddle();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fiddle();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'AvoidThrowingRawExceptionTypes', :description => 'Avoid throwing certain exception types.  Rather than throw a raw RuntimeException, Throwable,<br/> Exception, or Error, use a subclassed exception or error instead.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>public&nbsp;void&nbsp;bar()&nbsp;throws&nbsp;Exception&nbsp;{<br/>&nbsp;&nbsp;throw&nbsp;new&nbsp;Exception();<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'ExcessivePublicCount', :description => 'A large number of public methods and attributes declared in a class can indicate the<br/> class may need to be broken up as increased effort will be required to thoroughly test it.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;String&nbsp;value;<br/>&nbsp;public&nbsp;Bar&nbsp;something;<br/>&nbsp;public&nbsp;Variable&nbsp;var;<br/>&nbsp;//&nbsp;[...&nbsp;more&nbsp;more&nbsp;public&nbsp;attributes&nbsp;...]<br/>&nbsp;public&nbsp;void&nbsp;doWork()&nbsp;{}<br/>&nbsp;public&nbsp;void&nbsp;doMoreWork()&nbsp;{}<br/>&nbsp;public&nbsp;void&nbsp;doWorkAgain()&nbsp;{}<br/>&nbsp;//&nbsp;[...&nbsp;more&nbsp;more&nbsp;public&nbsp;methods&nbsp;...]<br/>}'
    StyleCheck.create :name => 'AccessorClassGeneration', :description => 'Instantiation by way of private constructors from outside of the constructor\'s class often causes the generation of an accessor.<br/>A factory method, or non-privitization of the constructor can eliminate this situation.<br/>The generated class file is actually an interface.  It gives the accessing class the ability to invoke a new hidden package<br/>scope constructor that takes the interface as a supplementary parameter.  This turns a private constructor effectively into<br/>one with package scope, though not visible to the naked eye.',  :example => 'public&nbsp;class&nbsp;Outer&nbsp;{<br/>&nbsp;void&nbsp;method(){<br/>&nbsp;&nbsp;Inner&nbsp;ic&nbsp;=&nbsp;new&nbsp;Inner();//Causes&nbsp;generation&nbsp;of&nbsp;accessor&nbsp;class<br/>&nbsp;}<br/>&nbsp;public&nbsp;class&nbsp;Inner&nbsp;{<br/>&nbsp;&nbsp;private&nbsp;Inner(){}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'SuspiciousEqualsMethodName', :description => 'The method name and parameter number are suspiciously close to<br/>equals(Object), which may mean you are intending to override the equals(Object)<br/>method.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;int&nbsp;equals(Object&nbsp;o)&nbsp;{<br/>&nbsp;//&nbsp;oops,&nbsp;this&nbsp;probably&nbsp;was&nbsp;supposed&nbsp;to&nbsp;be&nbsp;boolean&nbsp;equals<br/>&nbsp;}<br/>&nbsp;public&nbsp;boolean&nbsp;equals(String&nbsp;s)&nbsp;{<br/>&nbsp;//&nbsp;oops,&nbsp;this&nbsp;probably&nbsp;was&nbsp;supposed&nbsp;to&nbsp;be&nbsp;equals(Object)<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'UselessOperationOnImmutable', :description => 'An operation on an Immutable object (BigDecimal or BigInteger) won\'t change the object itself. The<br/>    result of the operation is a new object. Therefore, ignoring the operation result is an error.',  :example => 'import&nbsp;java.math.*;<br/>class&nbsp;Test&nbsp;{<br/>&nbsp;void&nbsp;method1()&nbsp;{<br/>&nbsp;&nbsp;BigDecimal&nbsp;bd=new&nbsp;BigDecimal(10);<br/>&nbsp;&nbsp;bd.add(new&nbsp;BigDecimal(5));&nbsp;//&nbsp;this&nbsp;will&nbsp;trigger&nbsp;the&nbsp;rule<br/>&nbsp;}<br/>&nbsp;void&nbsp;method2()&nbsp;{<br/>&nbsp;&nbsp;BigDecimal&nbsp;bd=new&nbsp;BigDecimal(10);<br/>&nbsp;&nbsp;bd&nbsp;=&nbsp;bd.add(new&nbsp;BigDecimal(5));&nbsp;//&nbsp;this&nbsp;won\'t&nbsp;trigger&nbsp;the&nbsp;rule<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'EmptySwitchStatements', :description => 'Avoid empty switch statements.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;int&nbsp;x&nbsp;=&nbsp;2;<br/>&nbsp;&nbsp;switch&nbsp;(x)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;//&nbsp;once&nbsp;there&nbsp;was&nbsp;code&nbsp;here<br/>&nbsp;&nbsp;&nbsp;//&nbsp;but&nbsp;it\'s&nbsp;been&nbsp;commented&nbsp;out&nbsp;or&nbsp;something<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'UnnecessaryFinalModifier', :description => 'When a class has the final modifier, all the methods are automatically final.',  :example => 'public&nbsp;final&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;This&nbsp;final&nbsp;modifier&nbsp;is&nbsp;not&nbsp;necessary,&nbsp;since&nbsp;the&nbsp;class&nbsp;is&nbsp;final<br/>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;and&nbsp;thus,&nbsp;all&nbsp;methods&nbsp;are&nbsp;final<br/>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;void&nbsp;foo()&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}'
    StyleCheck.create :name => 'AvoidCatchingThrowable', :description => 'This is dangerous because it casts too wide a net; it can catch things like OutOfMemoryError.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;bar()&nbsp;{<br/>&nbsp;&nbsp;try&nbsp;{<br/>&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something<br/>&nbsp;&nbsp;}&nbsp;catch&nbsp;(Throwable&nbsp;th)&nbsp;{&nbsp;&nbsp;//Should&nbsp;not&nbsp;catch&nbsp;throwable<br/>&nbsp;&nbsp;&nbsp;th.printStackTrace();<br/>&nbsp;&nbsp;}<br/>&nbsp;}<br/>}'
    StyleCheck.create :name => 'AvoidNonConstructorMethodsWithClassName', :description => 'It is very easy to confuse methods with classname with constructors. It is preferrable<br/>to name these non-constructor methods in a different way.',  :example => 'public&nbsp;class&nbsp;Foo&nbsp;{<br/>&nbsp;public&nbsp;void&nbsp;Foo()&nbsp;{<br/>&nbsp;&nbsp;//&nbsp;not&nbsp;a&nbsp;constructor,&nbsp;just&nbsp;a&nbsp;poorly&nbsp;named&nbsp;method<br/>&nbsp;}<br/>}'
 
 
    add_index :style_checks, [:name], :unique
  end

  def self.down
    drop_table :style_checks
  end
end
